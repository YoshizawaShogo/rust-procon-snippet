{
  "IS_PRIME": {
    "prefix": "IS_PRIME",
    "body": [
      "pub fn is_prime(num: usize) -> bool {",
      "    let end = (num as f64).sqrt().floor() as usize;",
      "    for i in 2..=end {",
      "        if num % i == 0 {",
      "            return false;",
      "        }",
      "    }",
      "    true",
      "}"
    ]
  },
  "PRIMES_UNDER": {
    "prefix": "PRIMES_UNDER",
    "body": [
      "pub fn primes_under(num: usize) -> Vec<usize> {",
      "    let mut may_be_prime_list = vec![true; num + 1];",
      "    may_be_prime_list[0] = false;",
      "    may_be_prime_list[1] = false;",
      "    let end = (num as f64).sqrt().floor() as usize;",
      "    for i in 2..=end {",
      "        if may_be_prime_list[i] {",
      "            let mut target = i + i;",
      "            while target <= num {",
      "                may_be_prime_list[target] = false;",
      "                target += i;",
      "            }",
      "        }",
      "    }",
      "    may_be_prime_list",
      "        .into_iter()",
      "        .enumerate()",
      "        .filter(|&(_, flag)| flag)",
      "        .map(|(index, _)| index)",
      "        .collect()",
      "}"
    ]
  },
  "PRIME_FACTORIZATION": {
    "prefix": "PRIME_FACTORIZATION",
    "body": [
      "pub fn prime_factorization(mut num: usize) -> Vec<usize> {",
      "    let end = (num as f64).sqrt().floor() as usize;",
      "    let mut primes = Vec::new();",
      "    for i in 2..=end {",
      "        while num % i == 0 {",
      "            primes.push(i);",
      "            num /= i;",
      "        }",
      "    }",
      "    if primes.len() == 0 {",
      "        primes.push(num);",
      "    }",
      "    primes",
      "}"
    ]
  },
  "bound_search": {
    "prefix": "bound_search",
    "body": [
      "fn bound_search<T>(mut met: T, mut violated: T, f: impl Fn(T) -> bool) -> T",
      "where",
      "    T: Copy",
      "        + std::ops::Add<Output = T>",
      "        + std::ops::Div<Output = T>",
      "        + std::ops::Sub<Output = T>",
      "        + PartialOrd",
      "        + From<u8>,",
      "{",
      "    debug_assert!(f(met));",
      "    debug_assert!(!f(violated));",
      "    let two = T::from(2);",
      "    while (met > violated && met - violated >= two) || (violated > met && violated - met >= two) {",
      "        let mid = (met + violated) / two;",
      "        if f(mid) {",
      "            met = mid;",
      "        } else {",
      "            violated = mid;",
      "        }",
      "    }",
      "    met",
      "}"
    ]
  },
  "bound_search_in_array": {
    "prefix": "bound_search_in_array",
    "body": [
      "fn bound_search_in_array<T: Clone>(",
      "    mut met: usize,",
      "    mut violated: usize,",
      "    array: &[T],",
      "    evaluate_fn: impl Fn(T) -> bool,",
      ") -> usize {",
      "    debug_assert!(array.get(met).is_some());",
      "    debug_assert!(evaluate_fn(array[met].clone()));",
      "    debug_assert!(array.get(violated).is_none() || !evaluate_fn(array[violated].clone()));",
      "    while met + 2 <= violated || violated + 2 <= met {",
      "        let mid = (met + violated) / 2;",
      "        let mid_value = array[mid].clone();",
      "        if evaluate_fn(mid_value) {",
      "            met = mid;",
      "        } else {",
      "            violated = mid;",
      "        }",
      "    }",
      "    met",
      "}"
    ]
  },
  "gcd": {
    "prefix": "gcd",
    "body": [
      "fn gcd<T>(mut a: T, mut b: T) -> T",
      "where",
      "    T: Copy + PartialEq + std::ops::Rem<Output = T> + std::ops::Sub<Output = T> + From<u8>,",
      "{",
      "    let zero: T = 0.into();",
      "    while b != zero {",
      "        (a, b) = (b, a % b);",
      "    }",
      "    a",
      "}"
    ]
  },
  "graph_distance_with_weight": {
    "prefix": "graph_distance_with_weight",
    "body": [
      "fn graph_distance_with_weight_from(",
      "    graph_to_weight: Vec<Vec<(usize, isize)>>,",
      "    start_node: usize,",
      ") -> Option<Vec<Option<isize>>> {",
      "    use std::cmp::Reverse;",
      "    use std::collections::BinaryHeap;",
      "    let node_num = graph_to_weight.len();",
      "    let mut distances = vec![None; node_num];",
      "    let mut schedules = BinaryHeap::new();",
      "    schedules.push((Reverse(0), start_node));",
      "    while let Some(here) = schedules.pop() {",
      "        let here_distance_candidate = here.0 .0;",
      "        let here_node = here.1;",
      "        if distances[here_node].is_none() {",
      "            let here_distance = here_distance_candidate;",
      "            distances[here_node] = Some(here_distance);",
      "            for &(next_node, weight) in graph_to_weight[here_node].iter() {",
      "                if distances[next_node].is_none() {",
      "                    let next_distance = here_distance as isize + weight;",
      "                    schedules.push((Reverse(next_distance), next_node))",
      "                }",
      "            }",
      "        }",
      "    }",
      "    for (from, to_weight_list) in graph_to_weight.iter().enumerate() {",
      "        let from_distamce = if let Some(x) = distances[from] {",
      "            x",
      "        } else {",
      "            continue;",
      "        };",
      "        for &(to, weight) in to_weight_list {",
      "            let to_distance = if let Some(x) = distances[to] {",
      "                x",
      "            } else {",
      "                continue;",
      "            };",
      "            let d = to_distance - from_distamce;",
      "            if d > weight {",
      "                return None;",
      "            }",
      "        }",
      "    }",
      "    Some(distances)",
      "}"
    ]
  },
  "graph_distance_without_weight": {
    "prefix": "graph_distance_without_weight",
    "body": [
      "fn graph_distance_without_weight_from(",
      "    graph: Vec<Vec<usize>>,",
      "    start_node: usize,",
      ") -> Vec<Option<usize>> {",
      "    let node_num = graph.len();",
      "    let mut distances = vec![None; node_num];",
      "    distances[start_node] = Some(0);",
      "    let mut schedules = vec![start_node];",
      "    while let Some(here) = schedules.pop() {",
      "        let here_distance = distances[here].unwrap();",
      "        let next_distance = Some(here_distance + 1);",
      "        for &next_node in graph[here].iter() {",
      "            if distances[next_node].is_none() {",
      "                distances[next_node] = next_distance;",
      "                schedules.push(next_node);",
      "            }",
      "        }",
      "    }",
      "    distances",
      "}"
    ]
  },
  "lazy_segment_tree": {
    "prefix": "lazy_segment_tree",
    "body": [
      "/// to edit",
      "type T = isize;",
      "/// to edit",
      "type L = isize;",
      "/// to edit",
      "fn identity_element() -> T {",
      "    0",
      "}",
      "/// to edit",
      "fn merge_data(a: Option<T>, b: Option<T>) -> Option<T> {",
      "    match (a, b) {",
      "        (Some(a), Some(b)) => Some(a.max(b)),",
      "        (Some(a), None) => Some(a),",
      "        (None, Some(b)) => Some(b),",
      "        (None, None) => None,",
      "    }",
      "}",
      "/// to edit",
      "fn commit_lazy(a: T, b: L) -> T {",
      "    a + b",
      "}",
      "/// to edit",
      "fn merge_lazy(a: Option<L>, b: Option<L>) -> Option<L> {",
      "    match (a, b) {",
      "        (Some(a), Some(b)) => Some(a + b),",
      "        (Some(a), None) => Some(a),",
      "        (None, Some(b)) => Some(b),",
      "        (None, None) => None,",
      "    }",
      "}",
      "/// [l, r)",
      "#[derive(PartialEq, Clone, Copy, Ord, PartialOrd, Eq)]",
      "struct Range {",
      "    l: usize,",
      "    r: usize,",
      "}",
      "impl Range {",
      "    fn new(l: usize, r: usize) -> Self {",
      "        debug_assert!(l < r);",
      "        Range { l, r }",
      "    }",
      "    fn len(&self) -> usize {",
      "        self.r - self.l",
      "    }",
      "    fn spilit_at_mid(self) -> (Range, Range) {",
      "        (",
      "            Range::new(self.l, (self.l + self.r + 1) / 2),",
      "            Range::new((self.l + self.r + 1) / 2, self.r),",
      "        )",
      "    }",
      "    fn contains(&self, &target: &Range) -> bool {",
      "        if self.l <= target.l && target.r <= self.r {",
      "            true",
      "        } else {",
      "            false",
      "        }",
      "    }",
      "    fn excludes(&self, &target: &Range) -> bool {",
      "        if target.r <= self.l || self.r <= target.l {",
      "            true",
      "        } else {",
      "            false",
      "        }",
      "    }",
      "}",
      "struct LazySegmentTree {",
      "    r_edge: usize,",
      "    data: Vec<Option<T>>,",
      "    lazy: Vec<Option<L>>,",
      "}",
      "impl LazySegmentTree {",
      "    fn new(size: usize) -> Self {",
      "        let mut i = 1;",
      "        while i < size {",
      "            i *= 2;",
      "        }",
      "        let n = 2 * i - 1;",
      "        let mut data = vec![None; n - i];",
      "        data.append(&mut vec![Some(identity_element()); i]);",
      "        LazySegmentTree {",
      "            r_edge: i,",
      "            data: data,",
      "            lazy: vec![None; n],",
      "        }",
      "    }",
      "    fn query(&mut self, target: &Range) -> T {",
      "        let valid_range = Range::new(0, self.r_edge);",
      "        debug_assert!(valid_range.contains(target));",
      "        self._query(target, None, 0, valid_range).unwrap()",
      "    }",
      "    fn _query(",
      "        &mut self,",
      "        target: &Range,",
      "        lazy_value: Option<L>,",
      "        current_i: usize,",
      "        current_range: Range,",
      "    ) -> Option<T> {",
      "        if target.excludes(&current_range) {",
      "            if let Some(lazy_sum) = merge_lazy(lazy_value, self.lazy[current_i]) {",
      "                self.data[current_i] = None;",
      "                self.lazy[current_i] = Some(lazy_sum);",
      "            }",
      "            return None;",
      "        } else if target.contains(&current_range) {",
      "            if let Some(data) = self.data[current_i] {",
      "                if let Some(lazy_sum) = merge_lazy(lazy_value, self.lazy[current_i]) {",
      "                    self.data[current_i] = Some(commit_lazy(data, lazy_sum));",
      "                    self.lazy[current_i] = None;",
      "                    if current_range.len() != 1 {",
      "                        self.lazy[current_i * 2 + 1] =",
      "                            merge_lazy(self.lazy[current_i * 2 + 1], Some(lazy_sum));",
      "                        self.lazy[current_i * 2 + 2] =",
      "                            merge_lazy(self.lazy[current_i * 2 + 2], Some(lazy_sum));",
      "                    }",
      "                }",
      "                return self.data[current_i];",
      "            } else {",
      "                let lazy_sum = merge_lazy(lazy_value, self.lazy[current_i]);",
      "                self.lazy[current_i] = None;",
      "                let (child_l, child_r) = current_range.spilit_at_mid();",
      "                let a = self._query(target, lazy_sum, current_i * 2 + 1, child_l);",
      "                let b = self._query(target, lazy_sum, current_i * 2 + 2, child_r);",
      "                self.data[current_i] = merge_data(a, b);",
      "                return self.data[current_i];",
      "            }",
      "        } else {",
      "            let lazy_sum = merge_lazy(lazy_value, self.lazy[current_i]);",
      "            self.lazy[current_i] = None;",
      "            let (child_l, child_r) = current_range.spilit_at_mid();",
      "            let a = self._query(target, lazy_sum, current_i * 2 + 1, child_l);",
      "            let b = self._query(target, lazy_sum, current_i * 2 + 2, child_r);",
      "            return merge_data(a, b);",
      "        };",
      "    }",
      "    fn update(&mut self, target: &Range, value: L) {",
      "        let valid_range = Range::new(0, self.r_edge);",
      "        debug_assert!(valid_range.contains(target));",
      "        self._update(target, value, None, 0, valid_range);",
      "    }",
      "    fn _update(",
      "        &mut self,",
      "        target: &Range,",
      "        value: L,",
      "        propagated: Option<L>,",
      "        current_i: usize,",
      "        current_range: Range,",
      "    ) {",
      "        let lazy_sum = merge_lazy(self.lazy[current_i], propagated);",
      "        if target.excludes(&current_range) {",
      "            self.lazy[current_i] = lazy_sum;",
      "            return;",
      "        } else if target.contains(&current_range) {",
      "            let lazy_sum = merge_lazy(lazy_sum, Some(value));",
      "            self.lazy[current_i] = lazy_sum;",
      "            return;",
      "        } else {",
      "            self.lazy[current_i] = None;",
      "            self.data[current_i] = None;",
      "            let (child_l, child_r) = current_range.spilit_at_mid();",
      "            self._update(target, value, lazy_sum, current_i * 2 + 1, child_l);",
      "            self._update(target, value, lazy_sum, current_i * 2 + 2, child_r);",
      "        }",
      "    }",
      "}"
    ]
  },
  "mod_int": {
    "prefix": "mod_int",
    "body": [
      "#[derive(Clone)]",
      "struct ModInt {",
      "    value: usize,",
      "    modulus: usize,",
      "    inv_div: std::collections::HashMap<usize, usize>,",
      "}",
      "impl ModInt {",
      "    fn new(modulus: usize, init: usize) -> Self {",
      "        Self {",
      "            value: init,",
      "            modulus: modulus,",
      "            inv_div: std::collections::HashMap::new(),",
      "        }",
      "    }",
      "    #[allow(unused)]",
      "    fn add(mut self, n: usize) -> Self {",
      "        let n = n % self.modulus;",
      "        self.value += n;",
      "        self.value %= self.modulus;",
      "        self",
      "    }",
      "    #[allow(unused)]",
      "    fn sub(mut self, n: usize) -> Self {",
      "        let n = n % self.modulus;",
      "        if self.value < n {",
      "            self.value += self.modulus - n;",
      "        } else {",
      "            self.value -= n;",
      "        }",
      "        self",
      "    }",
      "    #[allow(unused)]",
      "    fn mul(mut self, n: usize) -> Self {",
      "        let n = n % self.modulus;",
      "        self.value *= n;",
      "        self.value %= self.modulus;",
      "        self",
      "    }",
      "    #[allow(unused)]",
      "    fn div(mut self, n: usize) -> Self {",
      "        let n = n % self.modulus;",
      "        let inv_n = if let Some(inv_n) = self.inv_div.get(&n) {",
      "            *inv_n",
      "        } else {",
      "            let inv_n = mod_inv(n, self.modulus);",
      "            self.inv_div.insert(n, inv_n);",
      "            inv_n",
      "        };",
      "        self.value *= inv_n;",
      "        self.value %= self.modulus;",
      "        self",
      "    }",
      "}",
      "fn mod_inv(divisor: usize, modulus: usize) -> usize {",
      "    let mut a = divisor;",
      "    let mut b = modulus;",
      "    let mut inv: isize = 1;",
      "    let mut x: isize = 0;",
      "    while b != 0 {",
      "        (inv, x) = (x, inv - (a / b) as isize * x);",
      "        (a, b) = (b, a % b);",
      "    }",
      "    if inv < 0 {",
      "        (inv + modulus as isize) as usize",
      "    } else {",
      "        inv as usize",
      "    }",
      "}"
    ]
  },
  "no": {
    "prefix": "no",
    "body": [
      "println!(\"No\");"
    ]
  },
  "union_find": {
    "prefix": "union_find",
    "body": [
      "struct UnionFind {",
      "    parents: Vec<usize>,",
      "    heights: Vec<usize>,",
      "    weights: Vec<isize>,",
      "}",
      "#[allow(dead_code)]",
      "impl UnionFind {",
      "    fn new(n: usize) -> Self {",
      "        Self {",
      "            parents: (0..n).collect(),",
      "            heights: vec![1; n],",
      "            weights: vec![0; n],",
      "        }",
      "    }",
      "    fn root(&mut self, node: usize) -> (usize, isize) {",
      "        let p = self.parents[node];",
      "        if node == p {",
      "            (node, 0)",
      "        } else {",
      "            let (r, w) = self.root(p);",
      "            self.parents[node] = r;",
      "            self.weights[node] += w;",
      "            (self.parents[node], self.weights[node])",
      "        }",
      "    }",
      "    fn union(&mut self, n1: usize, n2: usize, w: isize) {",
      "        let (r1, w1) = self.root(n1);",
      "        let (r2, w2) = self.root(n2);",
      "        debug_assert!(!self.is_connected(n1, n2));",
      "        let h1 = self.heights[r1];",
      "        let h2 = self.heights[r2];",
      "        if h1 <= h2 {",
      "            self.parents[r1] = r2;",
      "            self.heights[r2] = self.heights[r2].max(self.heights[r1] + 1);",
      "            self.weights[r1] = w2 - w1 - w;",
      "        } else {",
      "            self.parents[r2] = r1;",
      "            self.heights[r1] = self.heights[r1].max(self.heights[r2] + 1);",
      "            self.weights[r2] = w1 - w2 + w;",
      "        }",
      "    }",
      "    fn is_connected(&mut self, n1: usize, n2: usize) -> bool {",
      "        let (r1, _w1) = self.root(n1);",
      "        let (r2, _w2) = self.root(n2);",
      "        r1 == r2",
      "    }",
      "    fn is_valid(&mut self, n1: usize, n2: usize, w: isize) -> bool {",
      "        let (_r1, w1) = self.root(n1);",
      "        let (_r2, w2) = self.root(n2);",
      "        w2 - w1 == w",
      "    }",
      "}"
    ]
  },
  "yes": {
    "prefix": "yes",
    "body": [
      "println!(\"Yes\");"
    ]
  }
}
