{
  "IS_PRIME": {
    "prefix": "IS_PRIME",
    "body": [
      "pub fn is_prime(num: usize) -> bool {",
      "    let end = (num as f64).sqrt().floor() as usize;",
      "    for i in 2..=end {",
      "        if num % i == 0 {",
      "            return false;",
      "        }",
      "    }",
      "    true",
      "}"
    ]
  },
  "PRIMES_UNDER": {
    "prefix": "PRIMES_UNDER",
    "body": [
      "pub fn primes_under(num: usize) -> Vec<usize> {",
      "    let mut may_be_prime_list = vec![true; num + 1];",
      "    may_be_prime_list[0] = false;",
      "    may_be_prime_list[1] = false;",
      "    let end = (num as f64).sqrt().floor() as usize;",
      "    for i in 2..=end {",
      "        if may_be_prime_list[i] {",
      "            let mut target = i + i;",
      "            while target <= num {",
      "                may_be_prime_list[target] = false;",
      "                target += i;",
      "            }",
      "        }",
      "    }",
      "    may_be_prime_list",
      "        .into_iter()",
      "        .enumerate()",
      "        .filter(|&(_, flag)| flag)",
      "        .map(|(index, _)| index)",
      "        .collect()",
      "}"
    ]
  },
  "PRIME_FACTORIZATION": {
    "prefix": "PRIME_FACTORIZATION",
    "body": [
      "pub fn prime_factorization(mut num: usize) -> Vec<usize> {",
      "    let end = (num as f64).sqrt().floor() as usize;",
      "    let mut primes = Vec::new();",
      "    for i in 2..=end {",
      "        while num % i == 0 {",
      "            primes.push(i);",
      "            num /= i;",
      "        }",
      "    }",
      "    if primes.len() == 0 {",
      "        primes.push(num);",
      "    }",
      "    primes",
      "}"
    ]
  },
  "binary_indexed_tree": {
    "prefix": "binary_indexed_tree",
    "body": [
      "/// 遅延セグメント木よりも機能が少ないが、",
      "/// 使いやすく、高速である事も多い",
      "struct BinaryIndexedTree<A>(Vec<A>)",
      "where",
      "    A: Sized + std::ops::AddAssign + Clone + Default;",
      "impl<A> BinaryIndexedTree<A>",
      "where",
      "    A: Sized + std::ops::AddAssign + Clone + Default + std::ops::Sub<Output = A>,",
      "{",
      "    /// i番目の要素にaddendを加算する",
      "    fn add(&mut self, mut i: usize, addend: A) {",
      "        debug_assert!(i < self.0.len());",
      "        i += 1;",
      "        while i <= self.0.len() {",
      "            self.0[i - 1] += addend.clone();",
      "            i += lsb(i);",
      "        }",
      "    }",
      "    /// [0, r) の合計を求める",
      "    fn sum_0_to_r(&self, r: usize) -> A {",
      "        debug_assert!(r <= self.0.len());",
      "        let mut i = r;",
      "        let mut sum = A::default();",
      "        while i != 0 {",
      "            sum += self.0[i - 1].clone();",
      "            i -= lsb(i);",
      "        }",
      "        sum",
      "    }",
      "    /// [l, r) の合計値を取得",
      "    fn sum_l_to_r(&self, l: usize, r: usize) -> A {",
      "        debug_assert!(l <= r);",
      "        debug_assert!(r <= self.0.len());",
      "        self.sum_0_to_r(r) - self.sum_0_to_r(l)",
      "    }",
      "}",
      "fn lsb(i: usize) -> usize {",
      "    i & i.wrapping_neg()",
      "}"
    ]
  },
  "bound_search": {
    "prefix": "bound_search",
    "body": [
      "fn bound_search<T>(mut met: T, mut violated: T, f: impl Fn(T) -> bool) -> T",
      "where",
      "    T: Copy",
      "        + std::ops::Add<Output = T>",
      "        + std::ops::Div<Output = T>",
      "        + std::ops::Sub<Output = T>",
      "        + PartialOrd",
      "        + From<u8>,",
      "{",
      "    debug_assert!(f(met));",
      "    debug_assert!(!f(violated));",
      "    let two = T::from(2);",
      "    while (met > violated && met - violated >= two) || (violated > met && violated - met >= two) {",
      "        let mid = (met + violated) / two;",
      "        if f(mid) {",
      "            met = mid;",
      "        } else {",
      "            violated = mid;",
      "        }",
      "    }",
      "    met",
      "}"
    ]
  },
  "bound_search_in_array": {
    "prefix": "bound_search_in_array",
    "body": [
      "fn bound_search_in_array<T: Clone>(",
      "    mut met: usize,",
      "    mut violated: usize,",
      "    array: &[T],",
      "    evaluate_fn: impl Fn(T) -> bool,",
      ") -> usize {",
      "    debug_assert!(array.get(met).is_some());",
      "    debug_assert!(evaluate_fn(array[met].clone()));",
      "    debug_assert!(array.get(violated).is_none() || !evaluate_fn(array[violated].clone()));",
      "    while met + 2 <= violated || violated + 2 <= met {",
      "        let mid = (met + violated) / 2;",
      "        let mid_value = array[mid].clone();",
      "        if evaluate_fn(mid_value) {",
      "            met = mid;",
      "        } else {",
      "            violated = mid;",
      "        }",
      "    }",
      "    met",
      "}"
    ]
  },
  "ext_euclid": {
    "prefix": "ext_euclid",
    "body": [
      "/// 拡張ユークリッド互除法",
      "/// g := gcd(a, b);",
      "/// a*x + b*y == gを満たす組(x, y)が少なくとも一つは存在する。",
      "/// Usage: (g, x, y) = ext_euclid(a, b);",
      "fn ext_euclid(a: i64, b: i64) -> (i64, i64, i64) {",
      "    let origin_a = a;",
      "    let origin_b = b;",
      "    debug_assert_ne!(origin_a, 0);",
      "    debug_assert_ne!(origin_b, 0);",
      "    let mut a = a;",
      "    let mut b = b;",
      "    let mut x = 1;",
      "    let mut y = 0;",
      "    if origin_a < origin_b {",
      "        (a, b) = (b, a);",
      "    }",
      "    while b != 0 {",
      "        (x, y) = (y, x - (a / b) * y);",
      "        (a, b) = (b, a % b);",
      "    }",
      "    if origin_a < origin_b {",
      "        (x, y) = (y, x);",
      "    }",
      "    (a, x, y)",
      "}"
    ]
  },
  "gcd": {
    "prefix": "gcd",
    "body": [
      "fn gcd<T>(mut a: T, mut b: T) -> T",
      "where",
      "    T: Copy + PartialEq + std::ops::Rem<Output = T> + std::ops::Sub<Output = T> + From<u8>,",
      "{",
      "    let zero: T = 0.into();",
      "    while b != zero {",
      "        (a, b) = (b, a % b);",
      "    }",
      "    a",
      "}"
    ]
  },
  "graph_distance_with_weight": {
    "prefix": "graph_distance_with_weight",
    "body": [
      "fn graph_distance_with_weight_from(",
      "    graph_to_weight: Vec<Vec<(usize, isize)>>,",
      "    start_node: usize,",
      ") -> Option<Vec<Option<isize>>> {",
      "    use std::cmp::Reverse;",
      "    use std::collections::BinaryHeap;",
      "    let node_num = graph_to_weight.len();",
      "    let mut distances = vec![None; node_num];",
      "    let mut schedules = BinaryHeap::new();",
      "    schedules.push((Reverse(0), start_node));",
      "    while let Some(here) = schedules.pop() {",
      "        let here_distance_candidate = here.0 .0;",
      "        let here_node = here.1;",
      "        if distances[here_node].is_none() {",
      "            let here_distance = here_distance_candidate;",
      "            distances[here_node] = Some(here_distance);",
      "            for &(next_node, weight) in graph_to_weight[here_node].iter() {",
      "                if distances[next_node].is_none() {",
      "                    let next_distance = here_distance as isize + weight;",
      "                    schedules.push((Reverse(next_distance), next_node))",
      "                }",
      "            }",
      "        }",
      "    }",
      "    for (from, to_weight_list) in graph_to_weight.iter().enumerate() {",
      "        let from_distamce = if let Some(x) = distances[from] {",
      "            x",
      "        } else {",
      "            continue;",
      "        };",
      "        for &(to, weight) in to_weight_list {",
      "            let to_distance = if let Some(x) = distances[to] {",
      "                x",
      "            } else {",
      "                continue;",
      "            };",
      "            let d = to_distance - from_distamce;",
      "            if d > weight {",
      "                return None;",
      "            }",
      "        }",
      "    }",
      "    Some(distances)",
      "}"
    ]
  },
  "graph_distance_without_weight": {
    "prefix": "graph_distance_without_weight",
    "body": [
      "fn graph_distance_without_weight_from(",
      "    graph: Vec<Vec<usize>>,",
      "    start_node: usize,",
      ") -> Vec<Option<usize>> {",
      "    let node_num = graph.len();",
      "    let mut distances = vec![None; node_num];",
      "    distances[start_node] = Some(0);",
      "    let mut schedules = vec![start_node];",
      "    while let Some(here) = schedules.pop() {",
      "        let here_distance = distances[here].unwrap();",
      "        let next_distance = Some(here_distance + 1);",
      "        for &next_node in graph[here].iter() {",
      "            if distances[next_node].is_none() {",
      "                distances[next_node] = next_distance;",
      "                schedules.push(next_node);",
      "            }",
      "        }",
      "    }",
      "    distances",
      "}"
    ]
  },
  "inversion_number": {
    "prefix": "inversion_number",
    "body": [
      "fn inversion_number(array: Vec<usize>) -> usize {",
      "    struct BinaryIndexedTree<A>(Vec<A>)",
      "    where",
      "        A: Sized + std::ops::AddAssign + Clone + Default;",
      "    impl<A> BinaryIndexedTree<A>",
      "    where",
      "        A: Sized + std::ops::AddAssign + Clone + Default,",
      "    {",
      "        fn add(&mut self, mut i: usize, addend: A) {",
      "            debug_assert!(i < self.0.len());",
      "            i += 1;",
      "            while i <= self.0.len() {",
      "                self.0[i - 1] += addend.clone();",
      "                i += lsb(i);",
      "            }",
      "        }",
      "        fn sum(&self, mut i: usize) -> A {",
      "            debug_assert!(i < self.0.len());",
      "            let mut sum = A::default();",
      "            i += 1;",
      "            while i != 0 {",
      "                sum += self.0[i - 1].clone();",
      "                i -= lsb(i);",
      "            }",
      "            sum",
      "        }",
      "    }",
      "    fn lsb(i: usize) -> usize {",
      "        i & i.wrapping_neg()",
      "    }",
      "    let mut bit = BinaryIndexedTree(vec![0; *array.iter().max().unwrap() + 1]);",
      "    let mut sum = 0;",
      "    for (i, &e) in array.iter().enumerate() {",
      "        sum += i - bit.sum(e);",
      "        bit.add(e, 1);",
      "    }",
      "    sum",
      "}"
    ]
  },
  "lazy_segment_tree": {
    "prefix": "lazy_segment_tree",
    "body": [
      "/// [l, r)",
      "/// to edit",
      "/// 値",
      "type T = isize;",
      "/// to edit",
      "/// 遅延値",
      "type L = isize;",
      "/// to edit",
      "/// 値の初期値",
      "fn identity_element() -> T {",
      "    0",
      "}",
      "/// to edit",
      "/// 子の値をマージして親の値を求める関数",
      "fn merge_value(a: Option<T>, b: Option<T>) -> Option<T> {",
      "    match (a, b) {",
      "        (Some(a), Some(b)) => Some(a + b),",
      "        (Some(a), None) => Some(a),",
      "        (None, Some(b)) => Some(b),",
      "        (None, None) => None,",
      "    }",
      "}",
      "/// to edit",
      "/// 遅延値を値に適用させる関数",
      "fn commit_lazy(a: T, b: Option<L>) -> T {",
      "    if let Some(b) = b {",
      "        a + b",
      "    } else {",
      "        a",
      "    }",
      "}",
      "/// to edit",
      "/// 二つの遅延値をマージして一つの遅延値にする関数",
      "fn merge_lazy(a: Option<L>, b: Option<L>) -> Option<L> {",
      "    match (a, b) {",
      "        (Some(a), Some(b)) => Some(a + b),",
      "        (Some(a), None) => Some(a),",
      "        (None, Some(b)) => Some(b),",
      "        (None, None) => None,",
      "    }",
      "}",
      "/// [l, r)",
      "#[derive(Debug, PartialEq, Clone, Copy, Ord, PartialOrd, Eq)]",
      "struct Range {",
      "    l: usize,",
      "    r: usize,",
      "}",
      "impl Range {",
      "    fn new(l: usize, r: usize) -> Self {",
      "        debug_assert!(l < r);",
      "        Range { l, r }",
      "    }",
      "    fn len(&self) -> usize {",
      "        self.r - self.l",
      "    }",
      "    fn spilit_at_mid(self) -> (Range, Range) {",
      "        (",
      "            Range::new(self.l, (self.l + self.r + 1) / 2),",
      "            Range::new((self.l + self.r + 1) / 2, self.r),",
      "        )",
      "    }",
      "    fn contains(&self, &target: &Range) -> bool {",
      "        if self.l <= target.l && target.r <= self.r {",
      "            true",
      "        } else {",
      "            false",
      "        }",
      "    }",
      "    fn excludes(&self, &target: &Range) -> bool {",
      "        if target.r <= self.l || self.r <= target.l {",
      "            true",
      "        } else {",
      "            false",
      "        }",
      "    }",
      "}",
      "/// data: 値、Noneの時はDirty、葉はDirtyにならない",
      "/// lazy: 遅延値",
      "/// update(): 値を適用",
      "/// query(): 値を取得",
      "#[derive(Debug)]",
      "struct LazySegmentTree {",
      "    r_edge: usize,",
      "    value: Vec<Option<T>>,",
      "    lazy_value: Vec<Option<L>>,",
      "}",
      "impl LazySegmentTree {",
      "    fn new(size: usize) -> Self {",
      "        let mut i = 1;",
      "        while i < size {",
      "            i *= 2;",
      "        }",
      "        let n = 2 * i - 1;",
      "        let mut data = vec![None; n - i];",
      "        data.append(&mut vec![Some(identity_element()); i]);",
      "        LazySegmentTree {",
      "            r_edge: i,",
      "            value: data,",
      "            lazy_value: vec![None; n],",
      "        }",
      "    }",
      "    fn query(&mut self, target: &Range) -> T {",
      "        let valid_range = Range::new(0, self.r_edge);",
      "        debug_assert!(valid_range.contains(target));",
      "        self._query(target, None, 0, valid_range).unwrap()",
      "    }",
      "    fn _query(",
      "        &mut self,",
      "        target: &Range,",
      "        lazy_value: Option<L>,",
      "        current_i: usize,",
      "        current_range: Range,",
      "    ) -> Option<T> {",
      "        let lazy_sum = merge_lazy(lazy_value, self.lazy_value[current_i]);",
      "        if target.excludes(&current_range) {",
      "            self.lazy_value[current_i] = lazy_sum;",
      "            return None;",
      "        }",
      "        if target.contains(&current_range) {",
      "            if let Some(data) = self.value[current_i] {",
      "                self.value[current_i] = Some(commit_lazy(data, lazy_sum));",
      "                self.lazy_value[current_i] = None;",
      "                if current_range.len() != 1 {",
      "                    self.lazy_value[current_i * 2 + 1] =",
      "                        merge_lazy(self.lazy_value[current_i * 2 + 1], lazy_sum);",
      "                    self.lazy_value[current_i * 2 + 2] =",
      "                        merge_lazy(self.lazy_value[current_i * 2 + 2], lazy_sum);",
      "                }",
      "                return self.value[current_i];",
      "            } else {",
      "                let (child_l, child_r) = current_range.spilit_at_mid();",
      "                let a = self._query(target, lazy_sum, current_i * 2 + 1, child_l);",
      "                let b = self._query(target, lazy_sum, current_i * 2 + 2, child_r);",
      "                self.value[current_i] = merge_value(a, b);",
      "                return self.value[current_i];",
      "            }",
      "        }",
      "        self.lazy_value[current_i] = None;",
      "        let (child_l, child_r) = current_range.spilit_at_mid();",
      "        let a = self._query(target, lazy_sum, current_i * 2 + 1, child_l);",
      "        let b = self._query(target, lazy_sum, current_i * 2 + 2, child_r);",
      "        return merge_value(a, b);",
      "    }",
      "    /// target[l, r)に対してvalueを適用",
      "    fn update(&mut self, target: &Range, lazy_value: L) {",
      "        let valid_range = Range::new(0, self.r_edge);",
      "        debug_assert!(valid_range.contains(target));",
      "        self._update(target, lazy_value, None, 0, valid_range);",
      "    }",
      "    /// valueとpropagatedは適用範囲が異なるため、両方必要",
      "    /// propagatedは無条件に親から子へ適用",
      "    /// valueはtargetに含まれている時のみ適用",
      "    /// 全部遅延させる。評価はqueryの際に行う",
      "    fn _update(",
      "        &mut self,",
      "        target: &Range,",
      "        lazy_value: L,",
      "        propagated: Option<L>,",
      "        current_i: usize,",
      "        current_range: Range,",
      "    ) {",
      "        let lazy_sum = merge_lazy(self.lazy_value[current_i], propagated);",
      "        if target.excludes(&current_range) {",
      "            self.lazy_value[current_i] = lazy_sum;",
      "            return;",
      "        }",
      "        if target.contains(&current_range) {",
      "            let lazy_sum = merge_lazy(lazy_sum, Some(lazy_value));",
      "            self.lazy_value[current_i] = lazy_sum;",
      "            return;",
      "        }",
      "        self.lazy_value[current_i] = None;",
      "        self.value[current_i] = None;",
      "        let (child_l, child_r) = current_range.spilit_at_mid();",
      "        self._update(target, lazy_value, lazy_sum, current_i * 2 + 1, child_l);",
      "        self._update(target, lazy_value, lazy_sum, current_i * 2 + 2, child_r);",
      "    }",
      "}"
    ]
  },
  "mod_inv": {
    "prefix": "mod_inv",
    "body": [
      "/// n/d ≡ n*inv (mod m). (nは任意の整数)",
      "/// 拡張ユークリッドの互除法を用いた。",
      "/// d*inv + m*x == GCD(d, m). (xは任意の整数)",
      "/// Usage: let inv = mod_inv(d, m);",
      "/// ただし、dとmは互いに素である必要がある",
      "fn mod_inv(divisor: usize, modulus: usize) -> usize {",
      "    debug_assert_ne!(divisor, 0);",
      "    debug_assert_ne!(modulus, 0);",
      "    let mut a = divisor;",
      "    let mut b = modulus;",
      "    let mut inv: isize = 1;",
      "    let mut x: isize = 0;",
      "    while b != 0 {",
      "        (inv, x) = (x, inv - (a / b) as isize * x);",
      "        (a, b) = (b, a % b);",
      "    }",
      "    debug_assert_eq!(a, 1);",
      "    if inv < 0 {",
      "        (inv + modulus as isize) as usize",
      "    } else {",
      "        inv as usize",
      "    }",
      "}"
    ]
  },
  "no": {
    "prefix": "no",
    "body": [
      "println!(\"No\");"
    ]
  },
  "union_find": {
    "prefix": "union_find",
    "body": [
      "/// parents: Vec<usize>, // 親を記録。自分を指し示している場合はroot。",
      "/// heights: Vec<usize>, // 木の高さ。root以外の高さは意味を持たない。unionを効率よく行うために保持",
      "/// sizes: Vec<usize>, // 木のサイズ。root以外のサイズは意味を持たない。",
      "/// distances: Vec<isize>, // rootとの距離(重み)",
      "struct UnionFind {",
      "    parents: Vec<usize>,",
      "    heights: Vec<usize>,",
      "    sizes: Vec<usize>,",
      "    distances: Vec<isize>,",
      "}",
      "#[allow(dead_code)]",
      "impl UnionFind {",
      "    fn new(n: usize) -> Self {",
      "        Self {",
      "            parents: (0..n).collect(),",
      "            heights: vec![1; n],",
      "            sizes: vec![1; n],",
      "            distances: vec![0; n],",
      "        }",
      "    }",
      "    fn root_distance(&mut self, node: usize) -> (usize, isize) {",
      "        let p = self.parents[node];",
      "        if node == p {",
      "            (node, 0)",
      "        } else {",
      "            let (r, d) = self.root_distance(p);",
      "            self.parents[node] = r;",
      "            self.distances[node] += d;",
      "            (self.parents[node], self.distances[node])",
      "        }",
      "    }",
      "    fn union(&mut self, n1: usize, n2: usize, w: isize) {",
      "        let (r1, w1) = self.root_distance(n1);",
      "        let (r2, w2) = self.root_distance(n2);",
      "        if self.is_connected(n1, n2) {",
      "            return;",
      "        }",
      "        let h1 = self.heights[r1];",
      "        let h2 = self.heights[r2];",
      "        if h1 <= h2 {",
      "            self.parents[r1] = r2;",
      "            self.heights[r2] = self.heights[r2].max(self.heights[r1] + 1);",
      "            self.sizes[r2] += self.sizes[r1];",
      "            self.distances[r1] = w2 - w1 - w;",
      "        } else {",
      "            self.parents[r2] = r1;",
      "            self.heights[r1] = self.heights[r1].max(self.heights[r2] + 1);",
      "            self.sizes[r1] += self.sizes[r2];",
      "            self.distances[r2] = w1 - w2 + w;",
      "        }",
      "    }",
      "    fn size(&mut self, node: usize) -> usize {",
      "        let r = self.root_distance(node).0;",
      "        self.sizes[r]",
      "    }",
      "    fn is_connected(&mut self, n1: usize, n2: usize) -> bool {",
      "        let (r1, _w1) = self.root_distance(n1);",
      "        let (r2, _w2) = self.root_distance(n2);",
      "        r1 == r2",
      "    }",
      "    fn is_valid(&mut self, n1: usize, n2: usize, w: isize) -> bool {",
      "        let (r1, w1) = self.root_distance(n1);",
      "        let (r2, w2) = self.root_distance(n2);",
      "        debug_assert!(r1 == r2);",
      "        w2 - w1 == w",
      "    }",
      "}"
    ]
  },
  "uniq_with_cnt": {
    "prefix": "uniq_with_cnt",
    "body": [
      "#[allow(unused_imports)]",
      "use std::collections::HashMap;",
      "fn uniq_with_cnt<T>(sorted: Vec<T>) -> HashMap<T, usize>",
      "where",
      "    T: Eq + std::hash::Hash,",
      "{",
      "    let mut counts = HashMap::new();",
      "    for e in sorted {",
      "        *counts.entry(e).or_insert(0) += 1;",
      "    }",
      "    counts",
      "}"
    ]
  },
  "yes": {
    "prefix": "yes",
    "body": [
      "println!(\"Yes\");"
    ]
  }
}
